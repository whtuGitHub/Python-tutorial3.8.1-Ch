[<<14.交互输入编辑和历史替换](../chap14/14.交互输入编辑和历史替换-Interactive_Input_Editing_and_History_Substitution.md)--[返回目录](../../Python教程目录.md)--[16.附录>>](../chap16/16.附录-Appendix.md)

# 15.浮点运算：问题和限制 (Floating Point Arithmetic: Issues and  Limitations)

浮点数在计算机硬件中表示为基数为2 (二进制) 的分数。例如，小数部分

```python
0.125
```

有值 `1/10 + 2/100 + 5/1000`, 同样地，二进制小数

```
0.001
```

有值 `0/2 + 0/4 + 1/8`. 这两个分数的值相同，唯一的区别是第一个分数是以10为基数，第二个分数是以2为基数。

遗憾的是，大多数十进制分数不能准确地表示为二进制分数。结果是，通常，您输入的十进制浮点数仅与实际存储在计算机中的二进制浮点数相近。

首先，这个问题在以10为基数的情况下比较容易理解。考虑分数1/3，你可以把它近似成以10为基数的分数：

```python
0.3
```

或更好的：

```
0.33
```

或更好的：

```
0.333
```

等等。不管你愿意写下多少位数字，结果永远不会是1/3，而是会越来越接近1/3。

同样，无论您愿意使用多少以2为基数的数字，小数0.1都不能准确地表示为以2为基数的分数。以2为基数时，1/10是如下的无限循环表示的分数：

```
0.0001100110011001100110011001100110011001100110011...
```

停在任何有限的位上，你就得到一个近似值。在今天的大多数机器上，浮点数是用一个二进制分数来近似的，分子是用最有效位开始的前53位表示，分母是2的幂。在`1/10`的情况下，二进制分数是`3602879701896397 / 2 ** 55`，接近但不完全等于1/10的真实值。

由于值的显示方式，许多用户意识不到近似值的问题。Python只打印由机器存储的二进制近似的接近真正十进制值的十进制近似值。在大多数机器上，如果Python要打印存储为0.1的二进制近似的真正的十进制值，则它显示为：

```python
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
```

这比大多数人认为有用的数字要多，因此Python通过显示一个四舍五入的值来保持数字位数的可管理性

```python
>>> 1 / 10
0.1
```

只要记住，即使打印出来的结果看起来是1/10的精确值，实际的存储值是最接近可表示的二进制分数。

有趣的是，有许多不同的十进制数具有相同的最接近的二进制分数。例如，数字 `0.1` 和 `0.10000000000000001` 和 `0.1000000000000000055511151231257827021181583404541015625` 都是 `3602879701896397 / 2 ** 55` 的近似值。由于所有这些十进制值都具有相同的近似值，因此以其中任何一个值的形式显示，表达式 `eval(repr(x)) == x` 结果保持不变 (Since all of these decimal values share the same approximation, any one of then could be displayed while preserving the invariant `eval(repr(x)) == x`)。

历史上，Python提示符窗口和内置的 [`repr()`](https://docs.python.org/3.8/library/functions.html#repr) 函数会选择有17个有效数字的数字，即0.10000000000000001。从Python 3.1开始，Python (在大多数系统上) 现在能够选择其中最短的一个并简单地显示`0.1`。

请注意，这正是二进制浮点的本质：这不是Python中的错误，也不是您的代码中的错误。您将在支持硬件浮点运算的所有语言中都会看到相同的情况 (尽管某些语言可能在默认情况下或在所有输出模式下不会显示差异)。

为了获得更好的输出效果，您可能希望使用字符串格式来生成有限位数的有效数字：

```python
>>> format(math.pi, '.12g')  # 指导12位有效数 give 12 significant digits
'3.14159265359'

>>> format(math.pi, '.2f')   # 指定两位小数 give 2 digits after the point
'3.14'

>>> repr(math.pi)
'3.141592653589793'
```

重要的是要认识到，这在实际意义上是一种错觉：您只是在舍入真实机器值的显示。

一个错觉可能引发另一个错觉。例如，由于0.1不完全是1/10，所以将三个0.1值相加可能也不完全是0.3：

```python
>>> .1 + .1 + .1 == .3
False
```

另外，由于0.1不能更接近1/10的确切值，而0.3也不能更接近3/10的确切值，因此使用  [`round()`](https://docs.python.org/3.8/library/functions.html#round) 函数进行**向前舍入 (pre-rounding)**是没有帮助的：

```python
>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
False
```

虽然无法使数字更接近其预期的精确值，但是 [`round()`](https://docs.python.org/3.8/library/functions.html#round) 函数对于**向后舍入 (post-rounding)**后舍入非常有用，这样具有不精确值的结果可以相互比较：

```python
>>> round(.1 + .1 + .1, 10) == round(.3, 10)
True
```

二进制浮点运算有很多类似的惊喜。关于`"0.1"`的问题在下面的 **“表示误差 (Representation Error)“** 部分有详细的解释。有关其他常见意外的更完整描述，请参见[浮点数的危险 (The Perils of Floating Point)](http://www.lahey.com/float.htm)。

正如最后所说，**”没有简单的答案“**。不过，不要过分害怕浮点运算！Python浮点运算中的错误是从浮点硬件继承而来的，而且在大多数机器上，每个操作的数量级不超过 `2**53` 分之一。这对于大多数任务来说已经足够了，但是您需要记住它不是十进制算术，而且每个浮点运算都可能出现新的舍入错误。

虽然病理情况确实存在，但是对于大多数浮点运算的偶然使用，如果您简单地将最终结果的显示四舍五入为您所期望的小数位数，你最后将看到你所期望的结果。[`str()`](https://docs.python.org/3.8/library/stdtypes.html#str) 通常就足够了，要获得更好的控制，请参见[格式字符串语法 (Format String Syntax)](https://docs.python.org/3.8/library/string.html#formatstrings) 中的 [`str.format()`](https://docs.python.org/3.8/library/stdtypes.html#str.format) 方法的格式说明符。

对于需要精确的十进制表示的用例，尝试使用 [`decimal`](https://docs.python.org/3.8/library/decimal.html#module-decimal) 模块，该模块实现适用于会计应用程序和高精度应用程序的十进制算术。

[分数 (`fractions`)](https://docs.python.org/3.8/library/fractions.html#module-fractions) 模块支持另一种形式的精确算术，它实现了基于有理数的算术 (所以像1/3这样的数字可以精确地表示)。

如果您是浮点运算的忠实用户，那么您应该看看**数值Python包 (Numerical Python package)** 以及[`SciPy`项目](https://scipy.org) (https://scipy.org) 提供的用于数学和统计操作的许多其他包。

Python提供了一些工具，当您确实想要知道浮点数的确切值时，这些工具可能会在一些罕见的情况下提供帮助。[`float.as_integer_ratio()`](https://docs.python.org/3.8/library/stdtypes.html#float.as_integer_ratio) 方法将浮点数的值表示为分数：

```python
>>> x = 3.14159
>>> x.as_integer_ratio()
(3537115888337719, 1125899906842624)
```

由于比例是精确的，它可以用来无损地重建初始值：

```python
>>> x == 3537115888337719 / 1125899906842624
True
```

 [`float.hex()`](https://docs.python.org/3.8/library/stdtypes.html#float.hex) 方法以十六进制 (以16为基数) 表示一个浮点数，并且给出计算机存储的确切值：

```python
>>> x.hex()
'0x1.921f9f01b866ep+1'
```

这种精确的十六进制表示法可用于精确地重构浮点值：

```python
>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True
```

由于表示是精确的，所以它有助于不同版本的Python (平台独立性) 间进行值的可靠移植以及利用支持相同格式的其他语言 (如Java和C99) 间交换数据。

另一个有用的工具是 [`math.fsum()`](https://docs.python.org/3.8/library/math.html#math.fsum) 函数，它可以帮助减少求和过程中的精度损失。它跟踪丢失的数字，并将值添加到正在运行的总数中。这可以在整体精度上产生差异，这样错误就不会累积到影响最终的总数的程度

```python
>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True
```

## 15.1.表示误差 (Representation Error)

本节将详细解释`"0.1"`示例，并展示你自己如何对类似的情况进行准确的分析。假设你基本熟悉二进制浮点表示法。

***表示误差*** 是指一些 (实际上是大多数) 十进制分数不能准确地表示为二进制 (以2为基数) 分数。这就是为什么Python (或Perl、C、c++、Java、Fortran和许多其他语言) 常常不能显示您所期望的精确小数的主要原因。

这是为什么呢?1/10不能精确表示为二进制分数。今天 (2000年11月) 几乎所有的机器都使用`IEEE-754`浮点运算，而且几乎所有平台都将Python浮点数映射到 `IEEE-754` “双精度”。`754` 双精度包含53位的精度，所以在电脑上输入`0.1`，电脑会努力将`0.1`转换为一个最接近的分数，这个分数可表示成 `J/2**N`这样的形式，其中`J`是准确包含53位的整数。重写为：

```python
1 / 10 ~= J / (2**N)
```

也可转换为：

```python
J ~= 2**N / 10
```

回想一下，`J`正好是53位(即 `>= 2**52` 但 `< 2**53`)，那么`N`最合适的值是56：

```python
>>> 2**52 <=  2**56 // 10  < 2**53
True
```

也就是说，56是`N`的唯一值使得`J`正好是53位。`J`的最可能的值是下面四舍五入后的商：

```
>>> q, r = divmod(2**56, 10)
>>> r
6
```

由于余数 (`6`) 大于10的一半，所以最合适的近似是通过向上舍入得到：

```python
>>> q+1
7205759403792794
```

因此，在754倍精度中，1/10的最佳可能近似值是：

```python
7205759403792794 / 2 ** 56
```

分子分母同时除以2，分数递减为：

```python
3602879701896397 / 2 ** 55
```

注意，由于进行了四舍五入 (即向上圆整)，这个值比1/10大一点；如果不是四舍五入，商会比1/10小一点。但在任何情况下，它都不可能恰好是1/10

所以计算机永远不会看到1/10：它看到的是上面给出的精确分数，它能得到的最好的754双精度近似：

```python
>>> 0.1 * 2 ** 55
3602879701896397.0
```

If we multiply that fraction by 10**55, we can see the value out to 55  decimal digits:

如果我们把这个分数乘以`10**55`，我们可以看到结果是55位小数：

```python
>>> 3602879701896397 * 10 ** 55 // 2 ** 55
1000000000000000055511151231257827021181583404541015625
```

这意味着存储在计算机中的确切数字等于十进制值`0.1000000000000000055511151231257827021181583404541015625`。许多语言 (包括较早版本的Python) 不会将这个值显示完整的小数值，而是将结果四舍五入为17位有效数字：

```python
>>> format(0.1, '.17f')
'0.10000000000000001'
```

 [`fractions`](https://docs.python.org/3.8/library/fractions.html#module-fractions) 和 [`decimal`](https://docs.python.org/3.8/library/decimal.html#module-decimal) 模块使这些计算变得简单：

```python
>>> from decimal import Decimal
>>> from fractions import Fraction

>>> Fraction.from_float(0.1)
Fraction(3602879701896397, 36028797018963968)

>>> (0.1).as_integer_ratio()
(3602879701896397, 36028797018963968)

>>> Decimal.from_float(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')

>>> format(Decimal.from_float(0.1), '.17')
'0.10000000000000001'
```

[<<14.交互输入编辑和历史替换](../chap14/14.交互输入编辑和历史替换-Interactive_Input_Editing_and_History_Substitution.md)--[返回目录](../../Python教程目录.md)--[16.附录>>](../chap16/16.附录-Appendix.md)